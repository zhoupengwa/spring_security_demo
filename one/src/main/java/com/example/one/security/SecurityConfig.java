package com.example.one.security;import com.example.one.security.decision.MyAccessDecisionManager;import com.example.one.security.decision.MyAccessDeniedHandler;import com.example.one.security.decision.MyAuthenticationEntryPoint;import com.example.one.security.decision.MySecurityMetadataSource;import com.example.one.security.login.MyUsernamePasswordAuthenticationFilter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.config.annotation.ObjectPostProcessor;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.web.access.intercept.FilterSecurityInterceptor;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;/** * @author zhoupeng create on 2021/7/13 */@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter {    @Autowired    private BackdoorAuthenticationProvider backdoorAuthenticationProvider;    @Autowired    private MyAuthenticationProvider1 myAuthenticationProvider;    @Autowired    private MyUserDetailService myUserDetailService;    @Autowired    private MyAccessDeniedHandler myAccessDeniedHandler;    @Autowired    private MySecurityMetadataSource mySecurityMetadataSource;    @Autowired    private MyAccessDecisionManager myAccessDecisionManager;    @Autowired    private MyAuthenticationEntryPoint myAuthenticationEntryPoint;    @Autowired    private MyUsernamePasswordAuthenticationFilter myUsernamePasswordAuthenticationFilter;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        /**         * 在内存中创建一个名为 "user" 的用户，密码为 "pwd"，拥有 "USER" 权限，密码使用BCryptPasswordEncoder加密         */        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser("user").password(new BCryptPasswordEncoder().encode("pwd"))                .roles("USER");        /**         * 在内存中创建一个名为 "admin" 的用户，密码为 "pwd"，拥有 "USER" 和"ADMIN"权限         */        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser("admin").password(new BCryptPasswordEncoder().encode("pwd"))                .roles("USER", "ADMIN");        //添加自定义验证逻辑，如果全都返回NULL，则最终还是使用内置的//        auth.authenticationProvider(backdoorAuthenticationProvider);//        auth.authenticationProvider(myAuthenticationProvider);        auth.userDetailsService(myUserDetailService).passwordEncoder(new BCryptPasswordEncoder());    }    /**     * 匹配 "/","/index" 路径，不需要权限即可访问     * 匹配 "/user" 及其以下所有路径，都需要 "USER" 权限     * 匹配 "/admin" 及其以下所有路径，都需要 "ADMIN" 权限     * 登录地址为 "/login"，登录成功默认跳转到页面 "/user"     * 退出登录的地址为 "/logout"，退出成功后跳转到页面 "/login"     */    @Override    protected void configure(HttpSecurity http) throws Exception {        http                .antMatcher("/**").authorizeRequests()                .withObjectPostProcessor((new ObjectPostProcessor<FilterSecurityInterceptor>() {                    @Override                    public <O extends FilterSecurityInterceptor> O postProcess(O object) {                        object.setSecurityMetadataSource(mySecurityMetadataSource);                        object.setAccessDecisionManager(myAccessDecisionManager);                        return object;                    }                }))                .anyRequest().authenticated()                .and()//                .formLogin().loginPage("/login_p").loginProcessingUrl("/login").permitAll()//                .usernameParameter("name").passwordParameter("pwd")//                .and()                .csrf().disable()                .exceptionHandling().authenticationEntryPoint(myAuthenticationEntryPoint)                .and().exceptionHandling().accessDeniedHandler(myAccessDeniedHandler)                .and().addFilterAt(myUsernamePasswordAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);    }    @Override    public void configure(WebSecurity web) throws Exception {        web.ignoring().antMatchers("/index.html", "/static/**", "/favicon.ico", "/error", "/login_p");    }}